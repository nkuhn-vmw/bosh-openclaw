<%
  # Port logic: SSO uses oauth2-proxy on 8080 → OpenClaw on 8081
  # Without SSO, OpenClaw listens directly on 8080
  sso_enabled = p('openclaw.sso.enabled')
  listen_port = sso_enabled ? 8081 : 8080

  # Auth mode: SSO → trusted-proxy (oauth2-proxy handles auth), otherwise token
  if sso_enabled
    auth = {
      "mode" => "trusted-proxy",
      "trustedProxy" => {
        "userHeader" => "X-Forwarded-User"
      }
    }
  else
    auth = {
      "mode" => "token",
      "token" => p('openclaw.gateway.token')
    }
  end

  # Trusted proxies: always include RFC1918 ranges since all traffic arrives
  # through CF gorouter. Without this, the gateway can't detect HTTPS
  # (gorouter terminates TLS) and restricts write scopes for the Control UI.
  # SSO also needs 127.0.0.1 for oauth2-proxy on localhost.
  trusted_proxies = ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"]
  trusted_proxies << "127.0.0.1" if sso_enabled

  # Build models.providers based on configured LLM provider
  # Each provider requires baseUrl and models (array of {id, name} objects)
  providers = {}

  provider = p('openclaw.llm.provider')

  if provider == 'genai' || provider == 'tanzu_genai'
    genai_endpoint = p('openclaw.llm.genai.endpoint', nil)
    genai_key = p('openclaw.llm.genai.api_key', nil)
    genai_model = p('openclaw.llm.genai.model')
    if genai_endpoint || genai_key
      # Ensure baseUrl includes /v1 for OpenAI-compatible APIs
      if genai_endpoint && !genai_endpoint.end_with?('/v1') && !genai_endpoint.end_with?('/v1/')
        genai_endpoint = genai_endpoint.chomp('/') + '/v1'
      end
      prov = { "api" => "openai-completions" }
      prov["baseUrl"] = genai_endpoint if genai_endpoint
      prov["apiKey"] = genai_key if genai_key
      # GenAI proxy (vLLM/TanzuAI) doesn't support stream_options
      # which OpenClaw sends by default for usage tracking
      genai_compat = { "supportsUsageInStreaming" => false }

      # Only specify models when a concrete model name is provided;
      # when "auto" or empty, omit models array so OpenClaw auto-discovers
      if genai_model && genai_model != "" && genai_model != "auto"
        prov["models"] = [{ "id" => genai_model, "name" => genai_model, "compat" => genai_compat }]
      end
      providers["genai"] = prov
    end
  end

  anthropic_key = p('openclaw.llm.anthropic.api_key', nil)
  if anthropic_key
    providers["anthropic"] = {
      "baseUrl" => "https://api.anthropic.com",
      "apiKey" => anthropic_key,
      "api" => "anthropic-messages",
      "models" => [{ "id" => "claude-sonnet-4-5-20250929", "name" => "Claude Sonnet 4.5" }]
    }
  end

  openai_key = p('openclaw.llm.openai.api_key', nil)
  if openai_key
    providers["openai"] = {
      "baseUrl" => "https://api.openai.com",
      "apiKey" => openai_key,
      "api" => "openai-completions",
      "models" => [{ "id" => "gpt-4o", "name" => "GPT-4o" }]
    }
  end

  # gateway.mode "local" is required for self-hosted gateway
  # gateway.bind must be an enum: "lan" binds to 0.0.0.0
  config = {
    "gateway" => {
      "mode" => "local",
      "bind" => "lan",
      "port" => listen_port,
      "auth" => auth
    },
    "models" => {
      "providers" => providers
    },
    "browser" => {
      "enabled" => p('openclaw.browser.enabled')
    },
    "logging" => {
      "level" => p('openclaw.logging.level')
    }
  }

  config["gateway"]["trustedProxies"] = trusted_proxies

  # Control UI settings for running behind CF gorouter:
  # - dangerouslyDisableDeviceAuth: Device pairing can never complete because
  #   clients behind gorouter are never "local" (X-Forwarded-For present).
  #   Token auth still protects access.
  # - allowedOrigins: Gorouter duplicates the Origin header (comma-separated),
  #   which breaks the built-in origin check. Explicitly allow the external URL.
  route_hostname = p('openclaw.route.hostname', nil)
  route_domain = p('openclaw.route.domain', nil)
  control_ui = { "dangerouslyDisableDeviceAuth" => true }
  if route_hostname && route_domain
    external_origin = "https://#{route_hostname}.#{route_domain}"
    control_ui["allowedOrigins"] = [external_origin]
  end
  config["gateway"]["controlUi"] = control_ui

  # Determine default model for agents: "provider/model-id"
  # This tells OpenClaw which model to use for chat
  default_model = nil
  if providers.any?
    provider_name = providers.keys.first
    provider_conf = providers[provider_name]
    if provider_conf["models"] && provider_conf["models"].any?
      # Specific model known: "genai/claude-sonnet-4-5-20250929"
      default_model = "#{provider_name}/#{provider_conf['models'].first['id']}"
    else
      # Auto-discover mode: just use provider name, OpenClaw picks first available
      default_model = provider_name
    end
  end

  if default_model
    config["agents"] = {
      "defaults" => {
        "model" => { "primary" => default_model }
      }
    }
  end

  # model_override takes precedence over auto-detected model
  model_override = p('openclaw.llm.model_override', nil)
  if model_override && model_override != ""
    config["agents"] = {
      "defaults" => {
        "model" => { "primary" => model_override }
      }
    }
  end
%>
<%= JSON.pretty_generate(config) %>
